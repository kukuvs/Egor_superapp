# Проект "Egor_superapp" — Системный монитор с клиент-серверной архитектурой на Python

Данный проект представляет собой системный монитор, реализованный в виде клиент-серверного приложения на Python. Серверная часть собирает системную информацию и обрабатывает команды, а клиентская часть предоставляет графический интерфейс для взаимодействия с сервером и отображения данных.

---

## Описание проекта

Проект состоит из двух основных компонентов:

1. **Сервер (main.py)** — отвечает за сбор системной информации и выполнение команд, полученных от клиента через разделяемую память.
2. **Клиент (gui.py)** — графический интерфейс на Tkinter, который отправляет запросы серверу и отображает полученные данные.

Связь между клиентом и сервером осуществляется через файл разделяемой памяти `/tmp/sysmon_shared_mem` с использованием mmap и блокировок файлов (fcntl), что обеспечивает синхронизацию и обмен данными между процессами.

---

## Сервер (main.py)

### Основные функции сервера

- **lock_file(f)** и **unlock_file(f)**  
  Функции для установки и снятия эксклюзивной блокировки файла с помощью `fcntl.flock`. Используются для синхронизации доступа к разделяемой памяти.

- **get_processes()**  
  Возвращает список текущих процессов в системе с информацией о PID, имени процесса и имени пользователя. Использует библиотеку `psutil`.

- **get_gpu_info()**  
  Получает информацию о видеокартах, используя команду `lspci | grep VGA`. Возвращает список строк с описанием GPU.

- **detect_file_creation()**  
  Обходит домашний каталог пользователя и находит файлы, созданные за последние 60 секунд. Возвращает список таких файлов или сообщение, если новых файлов нет.

- **get_uptime()**  
  Читает время работы системы из `/proc/uptime` и возвращает строку с временем в часах, минутах и секундах.

- **get_network_config()**  
  Получает конфигурацию сетевых интерфейсов, пытаясь выполнить `ifconfig -a`, а при ошибке — `ip addr`. Возвращает вывод команды.

- **execute_command(command)**  
  Выполняет произвольную shell-команду, переданную в параметре `command`, и возвращает результат выполнения или ошибку.

- **handle_request(request_json)**  
  Основная функция обработки входящих запросов в формате JSON. Распарсивает команду и вызывает соответствующую функцию. Возвращает JSON с результатом или ошибкой.

- **server_loop()**  
  Главный цикл сервера. Создаёт или открывает файл разделяемой памяти, ожидает запросы от клиента, обрабатывает их и записывает ответы обратно в разделяемую память, используя флаги состояния для синхронизации.

### Логика работы сервера

- Сервер работает только на Linux.
- Используется файл `/tmp/sysmon_shared_mem` размером 200 КБ для обмена данными.
- В начале файла один байт — флаг состояния:  
  - `0x00` — буфер пуст, клиент может писать запрос  
  - `0x01` — запрос записан, сервер может читать  
  - `0x02` — ответ записан, клиент может читать  
- Сервер в цикле ждёт появления флага запроса, читает JSON, обрабатывает команду, записывает ответ и меняет флаг на ответ.
- Используется блокировка файла для предотвращения гонок при чтении/записи.

---

## Клиент (gui.py)

### Описание интерфейса

Графический интерфейс реализован с помощью библиотеки Tkinter. Окно приложения содержит вкладки с различными функциями системного мониторинга и терминалом для выполнения команд.

### Вкладки и их функционал

1. **Processes (Процессы)**  
   - Кнопка "Get Processes" — отправляет запрос серверу на получение списка процессов.  
   - Таблица с колонками PID, Name, User отображает полученные процессы.

2. **GPU Info (Информация о GPU)**  
   - Кнопка "Get GPU Info" — запрашивает информацию о видеокартах.  
   - Текстовое поле отображает список видеокарт или ошибки.

3. **File Creation (Создание файлов)**  
   - Кнопка "Detect File Creation" — запрашивает список файлов, созданных за последние 60 секунд.  
   - Текстовое поле отображает результаты или ошибки.

4. **Uptime (Время работы системы)**  
   - Кнопка "Get Uptime" — запрашивает время работы системы.  
   - Метка отображает полученное время или ошибку.

5. **Network Config (Сетевые настройки)**  
   - Кнопка "Get Network Config" — запрашивает конфигурацию сетевых интерфейсов.  
   - Текстовое поле отображает вывод команды или ошибки.

6. **Terminal (Терминал)**  
   - Поле ввода для ввода произвольной shell-команды.  
   - Кнопка "Run Command" — отправляет команду серверу на выполнение.  
   - Текстовое поле отображает вывод команды или ошибку.

### Взаимодействие с сервером

- Клиент формирует JSON-запрос с командой и, при необходимости, дополнительными данными.
- Записывает запрос в разделяемую память, устанавливает флаг запроса.
- Ожидает ответа от сервера, читает ответ из разделяемой памяти.
- Обрабатывает и отображает полученные данные.
- Использует блокировки для синхронизации доступа к разделяемой памяти.

### Обработка ошибок

- Если сервер возвращает ошибку или возникает проблема с обменом данными, клиент отображает соответствующее сообщение в интерфейсе.
- При таймауте ожидания ответа выводится сообщение об ошибке.

---

## Как работает проект

1. Запускается сервер (`main.py`) на Linux-машине. Он создаёт файл разделяемой памяти и начинает слушать запросы.
2. Запускается клиент (`gui.py`), который открывает тот же файл разделяемой памяти.
3. Пользователь в клиенте выбирает вкладку и нажимает кнопку для запроса информации.
4. Клиент формирует JSON-запрос и записывает его в разделяемую память, меняет флаг.
5. Сервер обнаруживает флаг запроса, читает JSON, обрабатывает команду, формирует ответ и записывает его в разделяемую память, меняет флаг на ответ.
6. Клиент обнаруживает флаг ответа, читает данные, отображает их в интерфейсе.
7. Флаг сбрасывается в пустое состояние, и цикл повторяется.

---

## Используемые библиотеки

- `psutil` — для получения информации о процессах.
- `subprocess` — для выполнения системных команд.
- `mmap` и `fcntl` — для организации разделяемой памяти и синхронизации.
- `tkinter` — для создания графического интерфейса.
- `json` — для сериализации и десериализации данных между клиентом и сервером.
- `logging` — для ведения логов работы сервера и клиента.

---

## Запуск проекта

- Сервер запускается командой: `python3 main.py` (только на Linux).
- Клиент запускается командой: `python3 gui.py` (тоже на Linux).
- Клиент и сервер должны работать на одной машине, так как используют общий файл разделяемой памяти.

---

## Итог

Проект реализует простой, но функциональный системный монитор с возможностью удалённого выполнения команд и получения системной информации через разделяемую память. Графический интерфейс удобен для пользователя и позволяет быстро получать данные о процессах, GPU, недавно созданных файлах, времени работы системы, сетевых настройках и выполнять произвольные команды.

Данный проект может служить основой для изучения межпроцессного взаимодействия, работы с системными ресурсами и создания клиент-серверных приложений на Python с использованием Tkinter.
