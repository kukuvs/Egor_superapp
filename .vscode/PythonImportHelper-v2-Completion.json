[
    {
        "label": "runpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "runpy",
        "description": "runpy",
        "detail": "runpy",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "tkinter",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter",
        "description": "tkinter",
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "ttk",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "scrolledtext",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "mmap",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mmap",
        "description": "mmap",
        "detail": "mmap",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "fcntl",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "fcntl",
        "description": "fcntl",
        "detail": "fcntl",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "psutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "psutil",
        "description": "psutil",
        "detail": "psutil",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "bin_dir",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "bin_dir = os.path.dirname(abs_file)\nbase = bin_dir[: -len(\"Scripts\") - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"kukuvs-superapp\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "base",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "base = bin_dir[: -len(\"Scripts\") - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"kukuvs-superapp\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"PATH\"]",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "os.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"kukuvs-superapp\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"VIRTUAL_ENV\"]",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "os.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"kukuvs-superapp\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"VIRTUAL_ENV_PROMPT\"]",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "os.environ[\"VIRTUAL_ENV_PROMPT\"] = \"kukuvs-superapp\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "prev_length",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "prev_length = len(sys.path)\nfor lib in \"..\\\\Lib\\\\site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.path[:]",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "sys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.real_prefix",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "sys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.prefix",
        "kind": 5,
        "importPath": ".venv.Scripts.activate_this",
        "description": ".venv.Scripts.activate_this",
        "peekOfCode": "sys.prefix = base",
        "detail": ".venv.Scripts.activate_this",
        "documentation": {}
    },
    {
        "label": "App",
        "kind": 6,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "class App(tk.Tk):\n    def __init__(self):\n        super().__init__()\n        self.title(\"System Monitor\")\n        self.geometry(\"900x700\")\n        self.create_widgets()\n        if platform.system().lower() != 'linux':\n            logging.error(\"This client works only on Linux.\")\n            sys.exit(1)\n        tmp_dir = os.path.dirname(SHARED_MEM_FILE)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "lock_file",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def lock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_EX)\ndef unlock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_UN)\nclass App(tk.Tk):\n    def __init__(self):\n        super().__init__()\n        self.title(\"System Monitor\")\n        self.geometry(\"900x700\")\n        self.create_widgets()",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "unlock_file",
        "kind": 2,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "def unlock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_UN)\nclass App(tk.Tk):\n    def __init__(self):\n        super().__init__()\n        self.title(\"System Monitor\")\n        self.geometry(\"900x700\")\n        self.create_widgets()\n        if platform.system().lower() != 'linux':\n            logging.error(\"This client works only on Linux.\")",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "SHARED_MEM_FILE",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "SHARED_MEM_FILE = '/tmp/sysmon_shared_mem'\nSHARED_MEM_SIZE = 200 * 1024  # 10 KB\nFLAG_POS = 0\nFLAG_SIZE = 1\nDATA_POS = FLAG_POS + FLAG_SIZE\nFLAG_EMPTY = b'\\x00'\nFLAG_REQUEST = b'\\x01'\nFLAG_RESPONSE = b'\\x02'\ndef lock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_EX)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "SHARED_MEM_SIZE",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "SHARED_MEM_SIZE = 200 * 1024  # 10 KB\nFLAG_POS = 0\nFLAG_SIZE = 1\nDATA_POS = FLAG_POS + FLAG_SIZE\nFLAG_EMPTY = b'\\x00'\nFLAG_REQUEST = b'\\x01'\nFLAG_RESPONSE = b'\\x02'\ndef lock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_EX)\ndef unlock_file(f):",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "FLAG_POS",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "FLAG_POS = 0\nFLAG_SIZE = 1\nDATA_POS = FLAG_POS + FLAG_SIZE\nFLAG_EMPTY = b'\\x00'\nFLAG_REQUEST = b'\\x01'\nFLAG_RESPONSE = b'\\x02'\ndef lock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_EX)\ndef unlock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_UN)",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "FLAG_SIZE",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "FLAG_SIZE = 1\nDATA_POS = FLAG_POS + FLAG_SIZE\nFLAG_EMPTY = b'\\x00'\nFLAG_REQUEST = b'\\x01'\nFLAG_RESPONSE = b'\\x02'\ndef lock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_EX)\ndef unlock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_UN)\nclass App(tk.Tk):",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "DATA_POS",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "DATA_POS = FLAG_POS + FLAG_SIZE\nFLAG_EMPTY = b'\\x00'\nFLAG_REQUEST = b'\\x01'\nFLAG_RESPONSE = b'\\x02'\ndef lock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_EX)\ndef unlock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_UN)\nclass App(tk.Tk):\n    def __init__(self):",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "FLAG_EMPTY",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "FLAG_EMPTY = b'\\x00'\nFLAG_REQUEST = b'\\x01'\nFLAG_RESPONSE = b'\\x02'\ndef lock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_EX)\ndef unlock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_UN)\nclass App(tk.Tk):\n    def __init__(self):\n        super().__init__()",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "FLAG_REQUEST",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "FLAG_REQUEST = b'\\x01'\nFLAG_RESPONSE = b'\\x02'\ndef lock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_EX)\ndef unlock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_UN)\nclass App(tk.Tk):\n    def __init__(self):\n        super().__init__()\n        self.title(\"System Monitor\")",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "FLAG_RESPONSE",
        "kind": 5,
        "importPath": "gui",
        "description": "gui",
        "peekOfCode": "FLAG_RESPONSE = b'\\x02'\ndef lock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_EX)\ndef unlock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_UN)\nclass App(tk.Tk):\n    def __init__(self):\n        super().__init__()\n        self.title(\"System Monitor\")\n        self.geometry(\"900x700\")",
        "detail": "gui",
        "documentation": {}
    },
    {
        "label": "lock_file",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def lock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_EX)\ndef unlock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_UN)\ndef get_processes():\n    return [proc.info for proc in psutil.process_iter(['pid', 'name', 'username'])]\ndef get_gpu_info():\n    try:\n        result = subprocess.run('lspci | grep VGA', shell=True, stdout=subprocess.PIPE)\n        return result.stdout.decode('utf-8').strip().split('\\n')",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "unlock_file",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def unlock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_UN)\ndef get_processes():\n    return [proc.info for proc in psutil.process_iter(['pid', 'name', 'username'])]\ndef get_gpu_info():\n    try:\n        result = subprocess.run('lspci | grep VGA', shell=True, stdout=subprocess.PIPE)\n        return result.stdout.decode('utf-8').strip().split('\\n')\n    except Exception as e:\n        return [f\"Error getting GPU info: {e}\"]",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "get_processes",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def get_processes():\n    return [proc.info for proc in psutil.process_iter(['pid', 'name', 'username'])]\ndef get_gpu_info():\n    try:\n        result = subprocess.run('lspci | grep VGA', shell=True, stdout=subprocess.PIPE)\n        return result.stdout.decode('utf-8').strip().split('\\n')\n    except Exception as e:\n        return [f\"Error getting GPU info: {e}\"]\ndef detect_file_creation():\n    home = os.path.expanduser(\"~\")",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "get_gpu_info",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def get_gpu_info():\n    try:\n        result = subprocess.run('lspci | grep VGA', shell=True, stdout=subprocess.PIPE)\n        return result.stdout.decode('utf-8').strip().split('\\n')\n    except Exception as e:\n        return [f\"Error getting GPU info: {e}\"]\ndef detect_file_creation():\n    home = os.path.expanduser(\"~\")\n    recent_files = []\n    now = time.time()",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "detect_file_creation",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def detect_file_creation():\n    home = os.path.expanduser(\"~\")\n    recent_files = []\n    now = time.time()\n    try:\n        for root, dirs, files in os.walk(home):\n            for name in files:\n                path = os.path.join(root, name)\n                try:\n                    ctime = os.path.getctime(path)",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "get_uptime",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def get_uptime():\n    try:\n        with open('/proc/uptime', 'r') as f:\n            uptime_seconds = float(f.readline().split()[0])\n        h = int(uptime_seconds // 3600)\n        m = int((uptime_seconds % 3600) // 60)\n        s = int(uptime_seconds % 60)\n        return f\"Uptime: {h}h {m}m {s}s\"\n    except Exception as e:\n        return f\"Error getting uptime: {e}\"",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "get_network_config",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def get_network_config():\n    try:\n        try:\n            subprocess.run(['ifconfig'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)\n            cmd = 'ifconfig -a'\n        except Exception:\n            cmd = 'ip addr'\n        result = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        return result.stdout.decode('utf-8', errors='replace')\n    except Exception as e:",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "execute_command",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def execute_command(command):\n    try:\n        result = subprocess.run(command, shell=True, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        return result.stdout.decode('utf-8', errors='replace')\n    except subprocess.CalledProcessError as e:\n        return e.stderr.decode('utf-8', errors='replace')\ndef handle_request(request_json):\n    try:\n        logging.debug(f\"Handling request JSON: {request_json}\")\n        request = json.loads(request_json)",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "handle_request",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def handle_request(request_json):\n    try:\n        logging.debug(f\"Handling request JSON: {request_json}\")\n        request = json.loads(request_json)\n        cmd = request.get('command')\n        logging.debug(f\"Command received: {cmd}\")\n        if cmd == 'get_processes':\n            response = get_processes()\n        elif cmd == 'get_gpu_info':\n            response = get_gpu_info()",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "server_loop",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def server_loop():\n    logging.info(\"Starting server loop\")\n    # Проверка и создание файла разделяемой памяти\n    tmp_dir = os.path.dirname(SHARED_MEM_FILE)\n    if not os.path.exists(tmp_dir):\n        os.makedirs(tmp_dir, exist_ok=True)\n    if not os.path.exists(SHARED_MEM_FILE):\n        with open(SHARED_MEM_FILE, 'wb') as f:\n            f.write(b'\\x00' * SHARED_MEM_SIZE)\n    else:",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "SHARED_MEM_FILE",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "SHARED_MEM_FILE = '/tmp/sysmon_shared_mem'\nSHARED_MEM_SIZE = 200 * 1024  # 10 KB\nFLAG_POS = 0  # позиция флага в mmap\nFLAG_SIZE = 1  # размер флага в байтах\nDATA_POS = FLAG_POS + FLAG_SIZE  # позиция начала данных\n# Флаги состояния\nFLAG_EMPTY = b'\\x00'  # Буфер пуст, клиент может писать запрос\nFLAG_REQUEST = b'\\x01'  # Запрос записан, сервер может читать\nFLAG_RESPONSE = b'\\x02'  # Ответ записан, клиент может читать\ndef lock_file(f):",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "SHARED_MEM_SIZE",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "SHARED_MEM_SIZE = 200 * 1024  # 10 KB\nFLAG_POS = 0  # позиция флага в mmap\nFLAG_SIZE = 1  # размер флага в байтах\nDATA_POS = FLAG_POS + FLAG_SIZE  # позиция начала данных\n# Флаги состояния\nFLAG_EMPTY = b'\\x00'  # Буфер пуст, клиент может писать запрос\nFLAG_REQUEST = b'\\x01'  # Запрос записан, сервер может читать\nFLAG_RESPONSE = b'\\x02'  # Ответ записан, клиент может читать\ndef lock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_EX)",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "FLAG_POS",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "FLAG_POS = 0  # позиция флага в mmap\nFLAG_SIZE = 1  # размер флага в байтах\nDATA_POS = FLAG_POS + FLAG_SIZE  # позиция начала данных\n# Флаги состояния\nFLAG_EMPTY = b'\\x00'  # Буфер пуст, клиент может писать запрос\nFLAG_REQUEST = b'\\x01'  # Запрос записан, сервер может читать\nFLAG_RESPONSE = b'\\x02'  # Ответ записан, клиент может читать\ndef lock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_EX)\ndef unlock_file(f):",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "FLAG_SIZE",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "FLAG_SIZE = 1  # размер флага в байтах\nDATA_POS = FLAG_POS + FLAG_SIZE  # позиция начала данных\n# Флаги состояния\nFLAG_EMPTY = b'\\x00'  # Буфер пуст, клиент может писать запрос\nFLAG_REQUEST = b'\\x01'  # Запрос записан, сервер может читать\nFLAG_RESPONSE = b'\\x02'  # Ответ записан, клиент может читать\ndef lock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_EX)\ndef unlock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_UN)",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "DATA_POS",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "DATA_POS = FLAG_POS + FLAG_SIZE  # позиция начала данных\n# Флаги состояния\nFLAG_EMPTY = b'\\x00'  # Буфер пуст, клиент может писать запрос\nFLAG_REQUEST = b'\\x01'  # Запрос записан, сервер может читать\nFLAG_RESPONSE = b'\\x02'  # Ответ записан, клиент может читать\ndef lock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_EX)\ndef unlock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_UN)\ndef get_processes():",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "FLAG_EMPTY",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "FLAG_EMPTY = b'\\x00'  # Буфер пуст, клиент может писать запрос\nFLAG_REQUEST = b'\\x01'  # Запрос записан, сервер может читать\nFLAG_RESPONSE = b'\\x02'  # Ответ записан, клиент может читать\ndef lock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_EX)\ndef unlock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_UN)\ndef get_processes():\n    return [proc.info for proc in psutil.process_iter(['pid', 'name', 'username'])]\ndef get_gpu_info():",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "FLAG_REQUEST",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "FLAG_REQUEST = b'\\x01'  # Запрос записан, сервер может читать\nFLAG_RESPONSE = b'\\x02'  # Ответ записан, клиент может читать\ndef lock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_EX)\ndef unlock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_UN)\ndef get_processes():\n    return [proc.info for proc in psutil.process_iter(['pid', 'name', 'username'])]\ndef get_gpu_info():\n    try:",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "FLAG_RESPONSE",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "FLAG_RESPONSE = b'\\x02'  # Ответ записан, клиент может читать\ndef lock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_EX)\ndef unlock_file(f):\n    fcntl.flock(f.fileno(), fcntl.LOCK_UN)\ndef get_processes():\n    return [proc.info for proc in psutil.process_iter(['pid', 'name', 'username'])]\ndef get_gpu_info():\n    try:\n        result = subprocess.run('lspci | grep VGA', shell=True, stdout=subprocess.PIPE)",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "start_server",
        "kind": 2,
        "importPath": "run_app",
        "description": "run_app",
        "peekOfCode": "def start_server():\n    # Запуск серверной части\n    server_process = subprocess.Popen([sys.executable, 'server.py'])\n    return server_process\ndef start_gui():\n    # Запуск GUI части\n    gui_process = subprocess.Popen([sys.executable, 'gui.py'])\n    return gui_process\ndef main():\n    # Запуск сервера и GUI",
        "detail": "run_app",
        "documentation": {}
    },
    {
        "label": "start_gui",
        "kind": 2,
        "importPath": "run_app",
        "description": "run_app",
        "peekOfCode": "def start_gui():\n    # Запуск GUI части\n    gui_process = subprocess.Popen([sys.executable, 'gui.py'])\n    return gui_process\ndef main():\n    # Запуск сервера и GUI\n    server_process = start_server()\n    gui_process = start_gui()\n    try:\n        # Ожидание завершения процессов",
        "detail": "run_app",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "run_app",
        "description": "run_app",
        "peekOfCode": "def main():\n    # Запуск сервера и GUI\n    server_process = start_server()\n    gui_process = start_gui()\n    try:\n        # Ожидание завершения процессов\n        server_process.wait()\n        gui_process.wait()\n    except KeyboardInterrupt:\n        # Обработка завершения по Ctrl+C",
        "detail": "run_app",
        "documentation": {}
    }
]